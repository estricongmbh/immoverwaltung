import React, { useState, useEffect } from 'react';
import type { Firestore } from 'firebase/firestore';
import { writeBatch, doc, collection, Timestamp } from 'firebase/firestore';
import Papa from 'papaparse';
import { zaehlerZuordnung } from "./RecordForm"; // Importiere zaehlerZuordnung

interface SheetImporterProps {
    db: Firestore;
    userId: string;
    appId: string;
    onImportComplete: (importedDate: string) => void;
}

const TARGET_FIELDS = [
    { key: "apartmentId", label: "Wohnungs-ID (Pflichtfeld!)" },
    { key: "details.area", label: "Details: Fl√§che (m¬≤)" },
    { key: "details.location", label: "Details: Lage" },
    { key: "details.persons", label: "Details: Personenanzahl" },
    { key: "details.houseNumber", label: "Details: Hausnummer" },
    { key: "details.stellplatz1", label: "Details: Stellplatz 1" },
    { key: "details.stellplatz2", label: "Details: Stellplatz 2" },
    { key: "details.stellplatz3", label: "Details: Stellplatz 3" },
    { key: "tenants.tenant1.name", label: "Mieter 1: Name" },
    { key: "tenants.tenant1.phone", label: "Mieter 1: Telefon" },
    { key: "tenants.tenant1.email", label: "Mieter 1: E-Mail" },
    { key: "tenants.tenant2.name", label: "Mieter 2: Name" },
    { key: "tenants.tenant2.phone", label: "Mieter 2: Telefon" },
    { key: "tenants.tenant2.email", label: "Mieter 2: E-Mail" },
    { key: "contract.contractDate", label: "Vertrag: Datum" },
    { key: "contract.moveInDate", label: "Vertrag: Einzug" },
    { key: "contract.terminationDate", label: "Vertrag: Gek√ºndigt zum" },
    { key: "contract.contractEndDate", label: "Vertrag: Ende" },
    { key: "contract.kautionHoehe", label: "Kaution H√∂he (‚Ç¨)" },
    { key: "contract.kautionszahlungen", label: "Kautionszahlungen (JSON)" },
    { key: "rent.base", label: "Miete: Kaltmiete" },
    { key: "rent.utilities", label: "Miete: Nebenkosten" },
    { key: "rent.heating", label: "Miete: Heizkosten" },
    { key: "rent.parking", label: "Miete: Parkplatz" },
    { key: "payment.iban", label: "Zahlung: IBAN" },
    { key: "payment.directDebitMandateDate", label: "Zahlung: Datum Lastschrift" },
    { key: "payment.mandateReference", label: "Zahlung: Mandatsreferenz" },
    { key: "meterReadings.wasserzaehlerNrDigital", label: "Z√§hler: Wasser-Nr Digital" },
    { key: "meterReadings.wasserzaehlerStandDigital", label: "Z√§hler: Wasser-Stand Digital" },
    { key: "meterReadings.wasserzaehlerNrAnalog", label: "Z√§hler: Wasser-Nr Analog" },
    { key: "meterReadings.wasserzaehlerStandAnalog", label: "Z√§hler: Wasser-Stand Analog" },
    { key: "meterReadings.heizungNr", label: "Z√§hler: Heizung-Nr" },
    { key: "meterReadings.heizungStand", label: "Z√§hler: Heizung-Stand" },
    { key: "meterReadings.stromNr", label: "Z√§hler: Strom-Nr" },
    { key: "meterReadings.stromStand", label: "Z√§hler: Strom-Stand" },
    { key: "notes", label: "Notizen" },
];

const PROPERTY_LABELS: { [key: string]: string } = {
    TRI: "Triftstra√üe",
    PAS: "Pasewalker Str.",
    RITA: "Rosenthaler Str."
};

export const SheetImporter: React.FC<SheetImporterProps> = ({ db, userId, appId, onImportComplete }) => {
    const [apiKey] = useState<string>('AIzaSyDjQrJmmSRjnd47WeEMIm7qXQQde68LI4w');
    const [spreadsheetId] = useState<string>('1bqt-gnTwS0_zk6jGA_phat_v1pxNtSHYblPJVNbgDGY');
    const [sheets, setSheets] = useState<{ title: string }[]>([]);
    const [selectedSheet, setSelectedSheet] = useState<string>('');
    const [headers, setHeaders] = useState<string[]>([]);
    const [data, setData] = useState<any[][]>([]);
    const [mapping, setMapping] = useState<{ [columnIndex: number]: string }>({});
    const [isLoading, setIsLoading] = useState(false);
    const [status, setStatus] = useState('');
    const [error, setError] = useState('');
    const [effectiveDate, setEffectiveDate] = useState('');
    const [selectedObject, setSelectedObject] = useState('');
    const [showErrorModal, setShowErrorModal] = useState(false);
    const [errorEditRows, setErrorEditRows] = useState<any[]>([]); // F√ºr Editierfunktion

    const fetchSheets = async () => {
        setError(''); setIsLoading(true); setStatus('Lade Tabellenbl√§tter...');
        try {
            const response = await fetch(`https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}?key=${apiKey}`);
            const responseData = await response.json();
            if (responseData.error) { throw new Error(responseData.error.message || 'Unbekannter Fehler'); }
            setSheets(responseData.sheets.map((s: any) => ({ title: s.properties.title })));
            setStatus('Tabellenbl√§tter geladen. Bitte w√§hlen Sie eines aus.');
        } catch (e: any) {
            setError(`Fehler: ${e.message}.`);
        } finally { setIsLoading(false); }
    };

    const fetchSheetData = () => {
        if (!selectedSheet) return;
        setIsLoading(true); setStatus('Lade Daten aus Tabellenblatt...');
        setError('');
        const url = `https://docs.google.com/spreadsheets/d/${spreadsheetId}/gviz/tq?tqx=out:csv&sheet=${encodeURIComponent(selectedSheet)}`;
        Papa.parse(url, {
            download: true, header: false, skipEmptyLines: false,
            complete: (results) => {
                const rawData = results.data as any[][];
                // Dynamisch: Finde die erste Zeile mit >= 5 nicht-leeren Zellen als Header
                let headerRowIdx = -1;
                for (let i = 0; i < rawData.length; i++) {
                    const filled = rawData[i].filter(cell => String(cell).trim()).length;
                    if (filled >= 5) { headerRowIdx = i; break; }
                }
                if (headerRowIdx === -1) {
                    setError('Keine Kopfzeile mit ausreichend Spalten gefunden!');
                    setIsLoading(false); return;
                }
                const newHeaders = rawData[headerRowIdx].map((header, idx) => header || `Spalte ${idx + 1}`);
                setHeaders(newHeaders);

                // Automapping je nach effectiveDate (Stichtag)
                let stichtag = effectiveDate;
                // Fallback: versuche aus selectedSheet zu extrahieren, falls effectiveDate leer
                if (!stichtag && selectedSheet) {
                    const dateMatch = selectedSheet.match(/\d{4}-\d{2}-\d{2}/);
                    if (dateMatch) stichtag = dateMatch[0];
                }
                // Default: Mapping MIT Stellplatz 3 (ab 2024-11-01)
                let autoMapping: { [key: number]: string } = {
                    0: "details.houseNumber",
                    1: "details.location",
                    2: "apartmentId",
                    3: "tenants.tenant1.name",
                    4: "tenants.tenant2.name",
                    5: "details.area",
                    6: "rent.base",
                    8: "rent.utilities",
                    9: "rent.heating",
                    11: "details.stellplatz1",
                    12: "details.stellplatz2",
                    13: "details.stellplatz3",
                    15: "details.persons",
                    17: "tenants.tenant1.email",
                    18: "tenants.tenant1.phone",
                    19: "tenants.tenant2.email",
                    20: "tenants.tenant2.phone",
                    21: "contract.contractDate",
                    22: "contract.moveInDate",
                    23: "contract.kautionHoehe",
                    24: "contract.kautionszahlungen",
                    27: "meterReadings.wasserzaehlerNrAnalog",
                    28: "meterReadings.wasserzaehlerStandAnalog",
                    29: "meterReadings.wasserzaehlerNrDigital",
                    30: "meterReadings.wasserzaehlerStandDigital",
                    31: "meterReadings.heizungNr",
                    32: "meterReadings.heizungStand",
                    33: "meterReadings.stromNr",
                    34: "meterReadings.stromStand"
                };
                // Wenn das Stichtagsdatum vor 2024-11-01 liegt, Mapping OHNE Stellplatz 3
                if (stichtag && stichtag < "2024-11-01") {
                    autoMapping = {
                        0: "details.houseNumber",
                        1: "details.location",
                        2: "apartmentId",
                        3: "tenants.tenant1.name",
                        4: "tenants.tenant2.name",
                        5: "details.area",
                        6: "rent.base",
                        8: "rent.utilities",
                        9: "rent.heating",
                        11: "details.stellplatz1",
                        12: "details.stellplatz2",
                        // 13 entf√§llt (kein Stellplatz 3)
                        14: "details.persons",
                        16: "tenants.tenant1.email",
                        17: "tenants.tenant1.phone",
                        18: "tenants.tenant2.email",
                        19: "tenants.tenant2.phone",
                        20: "contract.contractDate",
                        21: "contract.moveInDate",
                        22: "contract.kautionHoehe",
                        23: "contract.kautionszahlungen",
                        26: "meterReadings.wasserzaehlerNrAnalog",
                        27: "meterReadings.wasserzaehlerStandAnalog",
                        28: "meterReadings.wasserzaehlerNrDigital",
                        29: "meterReadings.wasserzaehlerStandDigital",
                        30: "meterReadings.heizungNr",
                        31: "meterReadings.heizungStand",
                        32: "meterReadings.stromNr",
                        33: "meterReadings.stromStand"
                    };
                }
                setMapping(autoMapping);
                // Daten ab der n√§chsten Zeile
                const dataRows = rawData.slice(headerRowIdx + 1).filter(row => row.some(cell => String(cell).trim()));
                setData(dataRows);
                setStatus(`${dataRows.length} Datenzeilen geladen. Bitte Spalten zuordnen.`);
                setIsLoading(false);
            },
            error: (err: any) => { setError(`Fehler beim Verarbeiten der Sheet-Daten: ${err.message}`); console.error(err); setIsLoading(false); }
        });
    };

    const handleMappingChange = (columnIndex: number, dbField: string) => {
        setMapping(prev => ({ ...prev, [columnIndex]: dbField }));
    };

    // Hilfsfunktion: Vornamen-Geschlechtserkennung (vereinfachte Liste)
    function guessSalutation(firstName: string): string {
      const femaleNames = [
        "Anna", "Maria", "Sabine", "Petra", "Julia", "Laura", "Lisa", "Sophie", "Claudia", "Katrin", "Monika", "Susanne", "Sandra", "Nicole", "Andrea", "Christina", "Stefanie", "Nina", "Sarah", "Jessica", "Katharina", "Carina", "Lena", "Lea", "Michaela", "Vanessa", "Carolin", "Melanie", "Jana", "Tina", "Birgit", "Heike", "Ute", "Silke", "Martina", "Anja", "Sonja", "Daniela", "Angela", "Cornelia", "Renate", "Gabriele", "Elisabeth", "Theresa", "Helga", "Ingrid", "Marina", "Franziska", "Johanna", "Pauline", "Luisa", "Emilia", "Clara", "Helene", "Charlotte", "Emma", "Mia", "Hannah", "Sofia", "Lina", "Leonie", "Amelie", "Marie", "Emily", "Ella", "Anna-Lena", "Annika"
      ];
      if (!firstName) return "Herr";
      return femaleNames.some(n => n.toLowerCase() === firstName.toLowerCase()) ? "Frau" : "Herr";
    }

    // Hilfsfunktion: Fl√§che und Geldbetrag robust parsen
    function parseNumber(str: string): number {
      if (!str) return 0;
      // Entferne alles au√üer Ziffern, Komma, Punkt
      let cleaned = String(str).replace(/[^0-9,.-]/g, '');
      // Tausenderpunkt entfernen, falls vorhanden (z.B. 2.065,00)
      cleaned = cleaned.replace(/\.(?=\d{3}(,|$))/, '');
      // Komma zu Punkt
      cleaned = cleaned.replace(',', '.');
      const num = parseFloat(cleaned);
      return isNaN(num) ? 0 : num;
    }

    // Hilfsfunktion: Fl√§che aus "65 m¬≤" oder "65,00 m¬≤" extrahieren
    function parseArea(str: string): number {
      if (!str) return 0;
      let cleaned = String(str).replace(/[^0-9,.,-]/g, '');
      cleaned = cleaned.replace(',', '.');
      const num = parseFloat(cleaned);
      return isNaN(num) ? 0 : num;
    }

    // Hilfsfunktion: Datum ins ISO-Format bringen
    function parseToISODate(dateStr: string): string {
        // Wenn schon im ISO-Format, direkt zur√ºckgeben
        if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) return dateStr;
        // Wenn im deutschen Format (DD.MM.YYYY)
        const match = dateStr.match(/^(\d{2})\.(\d{2})\.(\d{4})$/);
        if (match) {
            const [, d, m, y] = match;
            return `${y}-${m}-${d}`;
        }
        return dateStr; // Fallback: unver√§ndert
    }    // Hilfsfunktion: Pr√ºft ob eine Zeile das Ende der Daten signalisiert    function isDataEndRow(originalMappedData: { [key: string]: string }, rowIndex: number): boolean {
        // Erste Spalte kann je nach Objekt unterschiedlich sein:
        // TRI/TRI-P: details.houseNumber (Hausnummer oder "P")
        // PAS/RITA: apartmentId (Wohnungs-ID)
        const firstColumnValue = selectedObject === 'TRI' || selectedObject.startsWith('TRI-') 
            ? (originalMappedData['details.houseNumber'] || '').toString().trim().toLowerCase()
            : (originalMappedData['apartmentId'] || '').toString().trim().toLowerCase();
        
        // Alternative: Falls die prim√§re Spalte leer ist, pr√ºfe die andere
        const alternativeColumnValue = selectedObject === 'TRI' || selectedObject.startsWith('TRI-')
            ? (originalMappedData['apartmentId'] || '').toString().trim().toLowerCase()
            : (originalMappedData['details.houseNumber'] || '').toString().trim().toLowerCase();
        
        // Weitere wichtige Spalten
        const lageText = (originalMappedData['details.location'] || '').toString().trim().toLowerCase();
        const mieterName = (originalMappedData['tenants.tenant1.name'] || '').toString().trim().toLowerCase();
        
        // Pr√ºfe auf Schl√ºsselw√∂rter, die das Ende der Daten signalisieren
        const endKeywords = ['summe', 'gesamt', 'total', 'j√§hrlich', 'monat', 'zusammenfassung', 'freie parkpl√§tze', 'freie', 'sum'];
        const hasEndKeyword = endKeywords.some(keyword => 
            firstColumnValue.includes(keyword) || 
            alternativeColumnValue.includes(keyword) ||
            mieterName.includes(keyword) || 
            lageText.includes(keyword)
        );
        
        // Pr√ºfe ob beide relevante Spalten leer sind (aber nicht bei Parkplatz-Zeilen mit "parkplatz" in der Lage)
        const isParkplatzRow = lageText.includes('parkplatz');
        const arePrimarySpaltenEmpty = !firstColumnValue && !alternativeColumnValue && !isParkplatzRow;
        
        // Zus√§tzliche Pr√ºfung: Wenn die ersten 3 Spalten komplett leer sind, ist es wahrscheinlich das Ende
        const allMainColumnsEmpty = !firstColumnValue && !alternativeColumnValue && !mieterName && !isParkplatzRow;
        
        // Debug-Ausgabe
        if (hasEndKeyword || arePrimarySpaltenEmpty || allMainColumnsEmpty) {
            console.log(`üõë Import-Stop bei Zeile ${rowIndex + 4}: firstColumn="${firstColumnValue}", alternativeColumn="${alternativeColumnValue}", mieterName="${mieterName}", hasEndKeyword=${hasEndKeyword}, primaryEmpty=${arePrimarySpaltenEmpty}, allEmpty=${allMainColumnsEmpty}, isParkplatz=${isParkplatzRow}`);
        }
        
        return hasEndKeyword || arePrimarySpaltenEmpty || allMainColumnsEmpty;
    }

    const handleImport = async () => {
        const errorRows: any[] = [];
        if (data.length === 0) { alert("Keine Daten zum Importieren vorhanden."); return; }
        if (!selectedObject || !effectiveDate) {
            alert("Fehler: Objekt oder Datum konnten nicht aus dem Tabellenblattnamen extrahiert werden.");
            return;
        }
        // --- NEU: Datum vorab pr√ºfen und normalisieren ---
        const isoDate = parseToISODate(effectiveDate);
        const dateObj = new Date(isoDate);
        if (isNaN(dateObj.getTime())) {
            alert(`Fehler: Das gew√§hlte Stichtagsdatum ('${effectiveDate}') ist ung√ºltig. Bitte im Format JJJJ-MM-TT oder TT.MM.JJJJ eingeben.`);
            return;
        }
        setIsLoading(true); setStatus(`Importiere ${data.length} Datens√§tze...`);
        const batch = writeBatch(db);
        const recordsPath = `propertyManagement/${appId}/users/${userId}/tenantRecords`;
        const recordsCollectionRef = collection(db, recordsPath);        for (let rowIndex = 0; rowIndex < data.length; rowIndex++) {
            const row = data[rowIndex];
            let recordData: any = { details: {}, tenants: {}, contract: {}, payment: {}, rent: {}, meterReadings: {}, notes: '' };
            let originalMappedData: { [key: string]: string } = {};
            row.forEach((cellValue, colIndex) => {
                const dbField = mapping[colIndex];
                if (dbField) {
                    originalMappedData[dbField] = cellValue ?? '';
                }
            });            // NEU: Pr√ºfe ob diese Zeile das Ende der Daten signalisiert
            if (isDataEndRow(originalMappedData, rowIndex)) {
                console.log(`‚úÖ Import gestoppt bei Zeile ${rowIndex + 4}. Verarbeite ${rowIndex} Datenzeilen.`);
                break; // Stoppe die Verarbeitung hier
            }const hausnrMaster = (originalMappedData['details.houseNumber'] || '').toString().trim().toUpperCase();
            const lageText = (originalMappedData['details.location'] || '').toString().trim().toLowerCase();
            const isParkplatzMasterRow = hausnrMaster === 'P' || lageText.includes('parkplatz');
            
            // Debug: Log f√ºr P-Zeilen-Erkennung
            if (hausnrMaster === 'P' || lageText.includes('parkplatz')) {
                console.log(`Debug Zeile ${rowIndex + 4}: Hausnummer="${hausnrMaster}", Lage="${originalMappedData['details.location']}", apartmentId="${originalMappedData['apartmentId']}", isParkplatz=${isParkplatzMasterRow}`);
            }            if (isParkplatzMasterRow) {
                const combinedParkingSheetId = (originalMappedData['apartmentId'] || '').toString().trim();
                
                // Verbesserte ID-Extraktion f√ºr Format "14+15", "2+9", etc.
                // Auch in Stellplatz-Spalten suchen, falls apartmentId leer ist
                let searchSources = [combinedParkingSheetId];
                if (!combinedParkingSheetId) {
                    // Fallback: In Stellplatz-Spalten suchen
                    searchSources = [
                        (originalMappedData['details.stellplatz1'] || '').toString().trim(),
                        (originalMappedData['details.stellplatz2'] || '').toString().trim(),
                        (originalMappedData['details.stellplatz3'] || '').toString().trim(),
                        (originalMappedData['details.stellplatz4'] || '').toString().trim()
                    ].filter(s => s !== '');
                }
                  let individualParkingIds: string[] = [];
                for (const source of searchSources) {
                    if (source && /\d/.test(source)) { // Wenn Quelle Zahlen enth√§lt
                        const extractedIds = source
                            .split(/[+,;\s]+/)
                            .map(id => id.trim())
                            .map(id => id.replace(/^P/i, '')) // Entferne "P" Pr√§fix falls vorhanden
                            .filter(id => id !== '' && /^\d+$/.test(id)); // Nur reine Zahlen akzeptieren
                        individualParkingIds.push(...extractedIds);
                    }
                }
                
                // Duplikate entfernen
                individualParkingIds = [...new Set(individualParkingIds)];
                
                console.log(`Debug Parkplatz-Zeile ${rowIndex + 4}: Input="${combinedParkingSheetId}", Suchquellen:`, searchSources, `Extracted IDs:`, individualParkingIds);
                
                // Wenn keine IDs gefunden wurden, Zeile einfach √ºberspringen (nicht als Fehler behandeln)
                if (individualParkingIds.length === 0) {
                    console.log(`√úberspringe Parkplatz-Zeile ${rowIndex + 4}: Keine g√ºltigen Parkplatz-IDs gefunden (m√∂glicherweise Platzhalter-Zeile)`);
                    continue; // Zeile √ºberspringen, aber keinen Fehler hinzuf√ºgen
                }
                
                // F√ºr jede Parkplatz-ID einen separaten Datensatz erstellen
                individualParkingIds.forEach(parkingIdSuffix => {
                    // Vollst√§ndige Parkplatz-Daten √ºbernehmen mit allen gew√ºnschten Feldern
                    const parkingSpotData: any = {
                        details: {
                            houseNumber: 'P',
                            // Stellpl√§tze √ºbernehmen
                            stellplatz1: originalMappedData['details.stellplatz1'] || '',
                            stellplatz2: originalMappedData['details.stellplatz2'] || '',
                            stellplatz3: originalMappedData['details.stellplatz3'] || '',
                            stellplatz4: originalMappedData['details.stellplatz4'] || ''
                        },
                        tenants: {
                            tenant1: {
                                name: originalMappedData['tenants.tenant1.name'] || '',
                                email: originalMappedData['tenants.tenant1.email'] || '',
                                phone: originalMappedData['tenants.tenant1.phone'] || ''
                            }
                        },
                        contract: {
                            contractDate: originalMappedData['contract.contractDate'] || '',
                            moveInDate: originalMappedData['contract.moveInDate'] || '',
                            terminationDate: originalMappedData['contract.terminationDate'] || '',
                            contractEndDate: originalMappedData['contract.contractEndDate'] || ''
                        },
                        payment: {
                            iban: originalMappedData['payment.iban'] || '',
                            mandateReference: originalMappedData['payment.mandateReference'] || ''
                        },
                        rent: {
                            base: parseNumber(originalMappedData['rent.base'] || '0'), // Kaltmiete
                            utilities: parseNumber(originalMappedData['rent.utilities'] || '0'),
                            heating: parseNumber(originalMappedData['rent.heating'] || '0'),
                            parking: parseNumber(originalMappedData['rent.parking'] || '0'),
                            total: parseNumber(originalMappedData['rent.base'] || '0') + 
                                   parseNumber(originalMappedData['rent.utilities'] || '0') + 
                                   parseNumber(originalMappedData['rent.heating'] || '0') + 
                                   parseNumber(originalMappedData['rent.parking'] || '0') // Gesamtmiete berechnet
                        },
                        meterReadings: {
                            wasserzaehlerNrDigital: '',
                            wasserzaehlerStandDigital: 0,
                            wasserzaehlerNrAnalog: '',
                            wasserzaehlerStandAnalog: 0,
                            heizungNr: '',
                            heizungStand: 0,
                            stromNr: '',
                            stromStand: 0
                        },
                        notes: `Importiert aus Zeile ${rowIndex + 4} (Parkplatz-Master), Parkplatz ${parkingIdSuffix}`
                    };
                    
                    // apartmentId: P + Nummer (z.B. P14, P15)
                    const parkingSpotFullApartmentId = 'P' + parkingIdSuffix;
                    const parkingFinalRecord = {
                        propertyCode: selectedObject + '-P', // z.B. TRI-P
                        apartmentId: parkingSpotFullApartmentId,
                        effectiveDate: Timestamp.fromDate(dateObj),
                        createdAt: Timestamp.now(),
                        changeType: 'Importiert',
                        data: parkingSpotData
                    };
                    
                    console.log(`Erstelle Parkplatz-Datensatz: ${parkingSpotFullApartmentId} f√ºr Objekt ${selectedObject + '-P'}`);
                    const parkingDocRef = doc(recordsCollectionRef);
                    batch.set(parkingDocRef, parkingFinalRecord);
                });
                continue; // Nach Verarbeitung der P-Zeile wird die gesamte Zeilenverarbeitung abgebrochen
            } else {
                // Nur f√ºr Nicht-P-Zeilen: PAS Spezialfall und normale Verarbeitung
            if (selectedObject === 'PAS') {
                const lage = originalMappedData['details.location'] || '';
                const wohnungsId = originalMappedData['apartmentId'] || '';
                if (lage.toLowerCase().includes('rosenthaler')) {
                    recordData.apartmentId = lage.slice(-3).trim();
                    recordData.details.location = '';
                } else {
                    recordData.apartmentId = wohnungsId;
                    recordData.details.location = lage;
                }
            } else {
                recordData.apartmentId = originalMappedData['apartmentId'];
                if (originalMappedData['details.location']) {
                    recordData.details.location = originalMappedData['details.location'];
                }
            }

            // --- Mapping und Spezialbehandlung ---
            for (const dbField in originalMappedData) {
                if (dbField === 'apartmentId' || dbField === 'details.location') continue;
                const keys = dbField.split('.');
                let currentLevel = recordData;
                for (let i = 0; i < keys.length - 1; i++) {
                    if (typeof currentLevel[keys[i]] !== 'object' || currentLevel[keys[i]] === null) {
                        currentLevel[keys[i]] = {};
                    }
                    currentLevel = currentLevel[keys[i]];
                }
                const lastKey = keys[keys.length - 1];
                const value = originalMappedData[dbField];

                // Name & Geschlecht
                if (dbField === 'tenants.tenant1.name' || dbField === 'tenants.tenant2.name') {
                    // Korrigierte Logik: Name splitten, Nachname und Vorname korrekt zuweisen
                    const parts = value ? value.trim().split(/\s+/) : [];
                    let firstName = '';
                    let lastName = '';
                    if (parts.length === 2) {
                        // Im deutschen Mietrecht ist oft Nachname Vorname, daher:
                        lastName = parts[0];
                        firstName = parts[1];
                    } else if (parts.length > 2) {
                        lastName = parts[0];
                        firstName = parts.slice(1).join(' ');
                    } else if (parts.length === 1) {
                        firstName = parts[0];
                        lastName = '';
                    }
                    const salutation = guessSalutation(firstName.split(' ')[0] || '');
                    currentLevel['name'] = value;
                    currentLevel['firstName'] = firstName;
                    currentLevel['lastName'] = lastName;
                    currentLevel['salutation'] = salutation;
                    continue;
                }
                // Fl√§che
                if (dbField === 'details.area') {
                    currentLevel[lastKey] = parseArea(value);
                    continue;
                }
                // Geldbetrag (Kaution, Miete, etc.)
                if (dbField.startsWith('rent.') || dbField === 'contract.kautionHoehe') {
                    currentLevel[lastKey] = parseNumber(value);
                    continue;
                }
                // Kautionszahlungen (JSON oder Einzelwert)
                if (dbField === 'contract.kautionszahlungen') {
                    try {
                        if (value && value.trim().startsWith('[')) {
                            currentLevel[lastKey] = JSON.parse(value);
                        } else if (value && value.trim()) {
                            // Einzelbetrag (z.B. "1234,56")
                            const betrag = parseNumber(value);
                            if (betrag > 0) {
                                currentLevel[lastKey] = [{ betrag, datum: '' }];
                            } else {
                                currentLevel[lastKey] = [];
                            }
                        } else {
                            currentLevel[lastKey] = [];
                        }
                    } catch {
                        currentLevel[lastKey] = [];
                    }
                    continue;
                }
                // Datum
                if (dbField.startsWith('contract.') && dbField.toLowerCase().includes('date')) {
                  const dateVal = value ? new Date(value) : null;
                  currentLevel[lastKey] = (dateVal && !isNaN(dateVal.getTime())) ? dateVal.toISOString().slice(0, 10) : '';
                  continue;
                }
                // Z√§hlernummern: Sheet-Wert bevorzugen, sonst Zuordnung
                const meterNumberFields = [
                  'meterReadings.wasserzaehlerNrDigital',
                  'meterReadings.wasserzaehlerNrAnalog',
                  'meterReadings.heizungNr',
                  'meterReadings.stromNr'
                ];
                if (meterNumberFields.includes(dbField)) {
                  currentLevel[lastKey] = value || '';
                  continue;
                }
                // Z√§hlerst√§nde: Sheet-Wert bevorzugen
                const meterReadingFields = [
                  'meterReadings.wasserzaehlerStandDigital',
                  'meterReadings.wasserzaehlerStandAnalog',
                  'meterReadings.heizungStand',
                  'meterReadings.stromStand'
                ];
                if (meterReadingFields.includes(dbField)) {
                  currentLevel[lastKey] = parseNumber(value);
                  continue;
                }
                // Standard
                currentLevel[lastKey] = value ?? '';
            }

            // apartmentId-Pr√ºfung und Logging wirklich NUR f√ºr Nicht-P-Zeilen!
            let aptIdTrimmed = (recordData.apartmentId || '').toString().trim();
            if (!aptIdTrimmed) {
                errorRows.push({
                    rowIndex: rowIndex + 4, // Sheet-Zeile (inkl. Header)
                    reason: 'Keine Wohnungs-ID erstellt werden konnte',
                    sentence: 'Keine Wohnungs-ID erstellt werden konnte',
                    row: [...row],
                    originalMappedData: { ...originalMappedData }
                });
                // continue; // Zeile wird nicht √ºbersprungen, sondern nur als Fehler geloggt
            } else {
                recordData.apartmentId = aptIdTrimmed;
                // --- Z√§hlernummern: Falls leer, Zuordnungslogik ---
                const wohnungsId = recordData.apartmentId;
                const zuordnung = zaehlerZuordnung[wohnungsId];
                if (zuordnung) {
                  if (!recordData.meterReadings.wasserzaehlerNrDigital) recordData.meterReadings.wasserzaehlerNrDigital = zuordnung.wasserzaehlerNrDigital || '';
                  if (!recordData.meterReadings.wasserzaehlerNrAnalog) recordData.meterReadings.wasserzaehlerNrAnalog = zuordnung.wasserzaehlerNrAnalog || '';
                  if (!recordData.meterReadings.heizungNr) recordData.meterReadings.heizungNr = zuordnung.heizungNr || '';
                  if (!recordData.meterReadings.stromNr) recordData.meterReadings.stromNr = zuordnung.stromNr || '';
                }
                // --- Wohnung importieren ---
                // Verwende das gepr√ºfte Datum f√ºr alle Datens√§tze
                const finalRecord = {
                    propertyCode: selectedObject,
                    apartmentId: recordData.apartmentId,
                    effectiveDate: Timestamp.fromDate(dateObj), // <--- gepr√ºfter Wert
                    createdAt: Timestamp.now(),
                    changeType: 'Importiert',
                    data: recordData
                };                const newDocRef = doc(recordsCollectionRef);
                batch.set(newDocRef, finalRecord);
            }
            } // Schlie√üende Klammer f√ºr else-Block (Nicht-P-Zeilen)
        }

        // Wenn Fehler aufgetreten sind, zeige Modal und breche Import ab
        if (errorRows.length > 0) {
            setErrorEditRows(errorRows.map(e => ({ ...e })));
            setShowErrorModal(true);
            setIsLoading(false);
            setStatus('Es wurden fehlerhafte Zeilen gefunden. Bitte korrigieren.');
            return; // <--- Import-Flow hier beenden!
        }

        // Nur wenn keine Fehler: commit und Alert
        try {
            await batch.commit();
            setStatus(`Import erfolgreich! ${data.length} Datens√§tze wurden geschrieben.`);
            alert("Import abgeschlossen!");
            onImportComplete(effectiveDate);
        } catch (e: any) {
            setError("Fehler beim Schreiben in die Datenbank: " + e.message);
        } finally { setIsLoading(false); }

        if (errorRows.length > 0) {
            setErrorEditRows(errorRows.map(e => ({ ...e }))); // Kopie f√ºr Editierfunktion
            setShowErrorModal(true);
        }
    };

    // Handler f√ºr das Speichern der korrigierten Zeilen
    const handleSaveErrorRows = async () => {
        setShowErrorModal(false);
        setIsLoading(true);
        const batch = writeBatch(db);
        const recordsPath = `propertyManagement/${appId}/users/${userId}/tenantRecords`;
        const recordsCollectionRef = collection(db, recordsPath);
        let savedCount = 0;
        for (const errorRow of errorEditRows) {
            let recordData: any = { details: {}, tenants: {}, contract: {}, payment: {}, rent: {}, meterReadings: {}, notes: '' };
            // Mapping wie im Import
            Object.entries(errorRow.originalMappedData).forEach(([dbField, value]) => {
                // ...Mapping-Logik wie oben...
                // Hier reicht f√ºr die Demo: apartmentId und details.location
                if (dbField === 'apartmentId') recordData.apartmentId = value;
                if (dbField === 'details.location') recordData.details.location = value;
            });
            if (!recordData.apartmentId) continue;
            const finalRecord = {
                propertyCode: selectedObject,
                apartmentId: recordData.apartmentId,
                effectiveDate: Timestamp.fromDate(new Date(parseToISODate(effectiveDate))),
                createdAt: Timestamp.now(),
                changeType: 'Importiert (manuell korrigiert)',
                data: recordData
            };
            const newDocRef = doc(recordsCollectionRef);
            batch.set(newDocRef, finalRecord);
            savedCount++;
        }
        await batch.commit();
        setIsLoading(false);
        setStatus(`${savedCount} korrigierte Datens√§tze wurden importiert.`);
        setErrorEditRows([]);
        setShowErrorModal(false);
    };

    useEffect(() => {
        if (selectedSheet) {
            const dateMatch = selectedSheet.match(/^\d{4}-\d{2}-\d{2}/);
            if (dateMatch) setEffectiveDate(dateMatch[0]);
            const objMatch = selectedSheet.match(/\b(TRI|PAS|RITA)\b$/i);
            if (objMatch) setSelectedObject(objMatch[1].toUpperCase());
        } else {
            setEffectiveDate('');
            setSelectedObject('');
        }
    }, [selectedSheet]);

return (
    <div className="mb-10 p-6 sm:p-8 bg-gray-800 text-gray-200 rounded-xl shadow-2xl border border-gray-700">
        <div className="flex justify-between items-center border-b border-gray-600 pb-4 mb-6">
            <h2 className="text-3xl font-semibold text-white">Google Sheet Import</h2>
            <div className="flex gap-4">
                 <button onClick={handleImport} disabled={isLoading || data.length === 0} className="px-5 py-2 text-sm bg-emerald-700 hover:bg-emerald-600 text-white font-semibold rounded-lg disabled:bg-gray-500">
                    {isLoading ? 'Importiere...' : 'Daten importieren'}
                </button>
                <button onClick={() => onImportComplete(effectiveDate || new Date().toISOString().split('T')[0])} className="px-5 py-2 text-sm bg-rose-700 hover:bg-rose-600 text-white font-semibold rounded-lg">
                    Abbrechen
                </button>
            </div>
        </div>


        <div className="space-y-6">
            <div className="flex flex-col sm:flex-row gap-4 items-center">
                <button onClick={fetchSheets} disabled={isLoading} className="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-700 w-full sm:w-auto">
                    {isLoading ? 'Lade...' : '1. Tabellenbl√§tter laden'}
                </button>

                {sheets.length > 0 && (
                    <select value={selectedSheet} onChange={e => setSelectedSheet(e.target.value)} className="block w-full p-2 border border-gray-600 bg-gray-700 rounded-md shadow-sm">
                        <option value="">-- 2. Tabellenblatt ausw√§hlen --</option>
                        {sheets.map(s => <option key={s.title} value={s.title}>{s.title}</option>)}
                    </select>
                )}

                {selectedSheet && (
                    <button onClick={fetchSheetData} disabled={!selectedSheet || isLoading} className="px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-700 w-full sm:w-auto">
                        3. Daten f√ºr Mapping laden
                    </button>
                )}
            </div>

            {error && <p className="text-red-400 text-sm mt-1">{error}</p>}

            {/* NEU: Bessere Anzeige f√ºr das erkannte Datum */}
            {selectedSheet && (
                <div className="p-3 bg-gray-700 border border-gray-600 rounded-lg">
                    <p className="text-sm text-gray-300">
                        Erkannt aus dem Blattnamen:
                        <span className="font-bold text-blue-400 ml-2">{PROPERTY_LABELS[selectedObject] || "..."}</span>
                        <span className="font-bold text-blue-400 ml-2">({effectiveDate || "Kein Datum erkannt"})</span>
                    </p>
                </div>
            )}

            {headers.length > 0 && data.length > 0 && (
            <div className="space-y-4">
                {/* Eingabefeld f√ºr das erkannte/zu importierende Datum */}
                <div className="mb-2">
                    <label className="block text-base font-medium text-gray-300 mb-1">Stichtagsdatum f√ºr Import</label>
                    <input
                        type="date"
                        className="bg-gray-800 border border-gray-600 rounded px-3 py-2 text-gray-200"
                        value={effectiveDate}
                        onChange={e => setEffectiveDate(e.target.value)}
                    />
                    <span className="text-xs text-gray-400 ml-2">(Wird f√ºr alle importierten Datens√§tze verwendet)</span>
                </div>
                <label className="block text-base font-medium text-gray-300">4. Spalten zuordnen</label>
                <div className="grid grid-cols-1 xl:grid-cols-2 gap-4">
                    {headers.map((header, index) => {
                        if (!header.trim() && data.every(row => !row[index])) return null;
                        const mappedFields = Object.entries(mapping)
                            .filter(([i, v]) => v && Number(i) !== index)
                            .map(([_, v]) => v);
                        return (
                            <div key={index} className="p-4 bg-gray-700 rounded-lg border border-gray-600 flex items-center justify-between gap-6">
                                <div style={{width: "280px"}} className="flex-shrink-0">
                                    <p className="font-bold text-blue-400 truncate" title={header || `Spalte ${index + 1}`}>
                                        {header && header.trim() ? header : `Spalte ${index + 1}`}
                                    </p>
                                    <div className="mt-1 text-xs text-gray-400 bg-gray-900 p-2 rounded border border-dashed border-gray-500 h-16 overflow-y-auto">
                                        {data.slice(0, 3).map((row, rowIndex) => (
                                            <p key={rowIndex} className="truncate">{row[index] || <span className="italic text-gray-500">leer</span>}</p>
                                        ))}
                                    </div>
                                </div>
                                <div style={{width: "280px"}} className="flex-shrink-0">
                                    <select value={mapping[index] || ''} onChange={e => handleMappingChange(index, e.target.value)} className="block w-full p-2 border border-gray-600 bg-gray-900 text-gray-200 rounded-md shadow-sm">
                                        <option value="">-- Nicht importieren --</option>
                                        {TARGET_FIELDS.filter(field => !mappedFields.includes(field.key) || mapping[index] === field.key).map(field => (
                                            <option key={field.key} value={field.key}>{field.label}</option>
                                        ))}
                                    </select>
                                </div>
                            </div>
                        )
                    })}
                </div>
            </div>
            )}

            {status && <p className="mt-2 text-sm font-medium">{status}</p>}

            <div className="flex gap-4 pt-6 border-t border-gray-600">
                 <button onClick={handleImport} disabled={isLoading || data.length === 0} className="px-8 py-3 bg-green-600 text-white font-semibold rounded-lg hover:bg-green-700 disabled:bg-gray-700 disabled:cursor-not-allowed">
                    {isLoading ? 'Importiere...' : 'Daten importieren'}
                </button>
                <button onClick={() => onImportComplete(effectiveDate || new Date().toISOString().split('T')[0])} className="px-8 py-3 bg-red-600 text-white font-semibold rounded-lg hover:bg-red-700">
                    Abbrechen
                </button>
            </div>
        </div>

        {/* Fehlerkorrektur-Modal */}
        {showErrorModal && (
            <div className="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50">
                <div className="bg-gray-900 border border-gray-600 rounded-lg p-8 w-full max-w-2xl">
                    <h3 className="text-lg font-bold text-red-400 mb-4">Fehlerhafte Zeilen ‚Äì bitte korrigieren</h3>
                    <div className="space-y-4 max-h-96 overflow-y-auto">
                        {errorEditRows.map((err, idx) => (
                            <div key={idx} className="bg-gray-800 border border-gray-700 rounded p-4 flex flex-col gap-2">
                                <div className="text-xs text-gray-400">Zeile im Sheet: {err.rowIndex} ‚Äì Grund: {err.reason}</div>
                                <div className="flex gap-2 items-center">
                                    <label className="text-sm">Wohnungs-ID:</label>
                                    <input type="text" value={err.originalMappedData.apartmentId || ''} onChange={e => {
                                        const newRows = [...errorEditRows];
                                        newRows[idx].originalMappedData.apartmentId = e.target.value;
                                        setErrorEditRows(newRows);
                                    }} className="bg-gray-700 border border-gray-500 rounded px-2 py-1 text-gray-200" />
                                </div>
                                <div className="flex gap-2 items-center">
                                    <label className="text-sm">Lage:</label>
                                    <input type="text" value={err.originalMappedData['details.location'] || ''} onChange={e => {
                                        const newRows = [...errorEditRows];
                                        newRows[idx].originalMappedData['details.location'] = e.target.value;
                                        setErrorEditRows(newRows);
                                    }} className="bg-gray-700 border border-gray-500 rounded px-2 py-1 text-gray-200" />
                                </div>
                                <div className="flex gap-2 items-center">
                                    <label className="text-sm">Mieter 1 Name:</label>
                                    <input type="text" value={err.originalMappedData['tenants.tenant1.name'] || ''} readOnly className="bg-gray-700 border border-gray-500 rounded px-2 py-1 text-gray-400 cursor-not-allowed" />
                                </div>
                                <div className="flex gap-2 items-center">
                                    <label className="text-sm">Kaltmiete:</label>
                                    <input type="text" value={err.originalMappedData['rent.base'] || ''} readOnly className="bg-gray-700 border border-gray-500 rounded px-2 py-1 text-gray-400 cursor-not-allowed" />
                                </div>
                                <div className="flex justify-end mt-2">
                                    <button onClick={() => {
                                        const newRows = errorEditRows.filter((_, i) => i !== idx);
                                        setErrorEditRows(newRows);
                                    }} className="btn btn-danger text-xs">Datensatz verwerfen</button>
                                </div>
                            </div>
                        ))}
                    </div>
                    <div className="flex gap-4 mt-6">
                        <button onClick={handleSaveErrorRows} className="btn btn-success">Korrigierte Zeilen importieren</button>
                        <button onClick={() => setShowErrorModal(false)} className="btn btn-danger">Abbrechen</button>
                    </div>
                </div>
            </div>
        )}
    </div>
);
};